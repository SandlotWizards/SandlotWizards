## üìò Purpose of This Document

This standard defines the **Command-Service Design Pattern** used throughout the Sandlot Software Factory. It governs the structure, behavior, and lifecycle of all command-driven service units.

This version is refactored to optimize for AI chunk retrieval first, while preserving human clarity.

---

## üî∂ How to Use This Standard

Use this document as the single authoritative reference when implementing or reviewing a Command-Service unit. Each section answers one question. Do not skip sections; each is required.

---

## üü® What Are the Required Inputs for a Command-Service?

| Name              | Type   | Required | Description                                       |
| ----------------- | ------ | -------- | ------------------------------------------------- |
| `solution`        | string | ‚úÖ        | Name of the solution where this service operates  |
| `project`         | string | ‚úÖ        | Target project name                               |
| `service-name`    | string | ‚úÖ        | Name of the service being generated               |
| `design-doc-path` | path   | ‚úÖ        | Path to the `DesignSpec.md` to interpret          |
| `--add`           | flag   | optional | Indicates a new behavior is added                 |
| `--delete`        | flag   | optional | Indicates behavior or objects are removed         |
| `--reset`         | flag   | optional | Resets the implementation                         |
| `--refactor`      | flag   | optional | Refactors internal design without external change |
| `--ai-rebuild`    | flag   | optional | Triggers full regeneration from AI pipeline       |

Exactly one or more of the flags must be passed.

---

## üß© How Should Commands Be Implemented? (`{ServiceName}Command.cs`)

- File name: `{ServiceName}Command.cs`
- Namespace: `{SolutionName}.Commands`
- Class declaration: `public sealed class {ServiceName}Command : ICommand`
- Must not declare a constructor
- Must define:
  - `public string Name => "...";`
  - `public string Description => "...";`
  - One public property per input (see above)
  - Method: `public async Task ExecuteAsync(CommandContext context)`

### Behavior:

- `ExecuteAsync` must begin with `ActionLog.Global.BeginStep(...)`
- Must resolve orchestrator via `context.Resolve<I{ServiceName}Service>()`
- Must call `await service.OrchestrateAsync(this);`

---

## üß≠ How Should the Orchestrator Be Implemented? (`{ServiceName}Service.cs`)

- File name: `{ServiceName}Service.cs`
- Namespace: `{SolutionName}.Services.{ServiceName}Service`
- Class declaration: `internal partial class {ServiceName}Service`
- Constructor: must use explicit DI injection

### Method `OrchestrateAsync()`:

- Must begin with `ActionLog.Global.BeginStep(...)`
- Must first call `ValidateContextAsync()` if it exists
- If validation fails:
  - Log using `ActionLog.Global.Error(...)`
  - Return early
- Then call SRP methods in logical sequence

---

## ‚öôÔ∏è How to Implement SRP Partial Methods

- File: one per method (e.g., `CreateWorkspace.cs`)
- Each method:
  - Must be declared `private async Task`
  - Must begin with `ActionLog.Global.BeginStep(...)`
  - Must perform only one logical responsibility
  - Must not share state unless via readonly DI
  - Return values (e.g. `ValidationResult`) must be evaluated in orchestrator

---

## üîç How to Handle Context Validation

### `ValidateContextAsync()` method (optional but recommended):

- Must be first method called in `OrchestrateAsync`
- Used to check external conditions, existence, auth, etc.
- If omitted, your design must address risks of partial execution

### If Validation Fails:

- Log the error clearly
- Do not continue SRP execution

---

## üõ° How to Prevent Partial Execution Risk

If validation is omitted or scattered:

- Your service may partially execute and corrupt state
- This is considered a design flaw
- Either centralize checks or explicitly accept and mitigate the risk

---

## üîê How to Manage State and Dependency Injection

- Only readonly DI fields are allowed
- Avoid shared mutable state
- Public properties must be justified if used for tracking or state transfer

---

## üì¶ What Files Should Be Generated by This Pattern?

```
source_code/Commands/
  {ServiceName}Command.cs

source_code/Services/{ServiceName}Service/
  {ServiceName}Service.cs
  {MethodName}.cs

copilot_instructions/
  CopilotInstructions.json
```

---

## ü™õ How to Build Post-AI Execution Instructions

In `CopilotInstructions.json`, include:

```powershell
"echo lore get-repo --repo-name {solution} --branch {ecId}"
"echo Expand-Archive -Path './copilot_output.zip' -DestinationPath './working/{ecId}/source_code'"
"echo copy ./working/{ecId}/source_code/* to ./repos/{solution}/src/"
"echo lore get-commit --message \"Adding command-service for {ServiceName}\""
"echo lore get-push"
"echo Remove-Item -Recurse -Force ./working/{ecId}"
```

---

## üîç How to Enforce Structured Logging

- Every orchestrator and SRP method must use `ActionLog.Global.BeginStep(...)`
- Optional: use `ActionLog.Global.Step(...)` for substeps
- No manual numbering allowed in log messages

---

## üîÑ How This Pattern Evolves

You may extend this pattern with structured validators, response builders, or domain-level abstractions ‚Äî **only** if the core orchestration and service isolation principles remain intact.

---

## üìò Additional Rules

This standard works in concert with:

- `Core.SoftwareDevelopment.Standard.md`
- `ActionLogger.Factory.Usage.Standard.md`

AI must not call platform APIs directly ‚Äî all interaction must go through approved interfaces (file system, datetime, SQL, etc.).

